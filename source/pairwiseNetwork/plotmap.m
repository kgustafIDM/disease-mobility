function [handles] = plotmap(S, values, varargin)
% S = shapefile stucture generated by loadshapefile()
% values = data values for each polygon in the shapefile
%

options = struct('key',[], 'colormap',copper(128), 'density',false, 'labels',false, 'border',[0 0 0],'clim',[],...
                 'textcolor','black', 'axishandle',[], 'buttondownfcn',[], 'figurehandle',[], 'handles',[], 'colorbar',true,'linewidth',1);
             
%read optional parameters
for pair = reshape(varargin,2,[])
    inpName = lower(pair{1}); %make case insensitive
    if any(strcmp(inpName, fieldnames(options)))
        options.(inpName) = pair{2};
    else   error('%s is not a recognized parameter name.\n', inpName);
    end;
end;

if(isempty(options.handles))
    handles = struct('Axes',[], 'Colorbar',[], 'dots',[], 'text',[], 'polygons',{{}});
else
    handles = options.handles;
end
if(~isempty(options.axishandle))
    handles.Axes = options.axishandle;
else
    handles.Axes = gca();
end;

hold(handles.Axes, 'on');

% valindex is a map from options.key to S.keys
values = reshape(values, [], 1);
if(isempty(options.key))
    if(length(values) ~= length(S.polygons)), error('The length of data values must match the number of polygons when a key is not provided'); end;
    CData = values;
else
    
    CData = nan(length(S.polygons), 1);
    for i = 1:length(values)
        ix = (options.key(i) == S.keys); % keys can be duplicated in the shapefile when polygons are grouped. Assign the data to all matching polygons.
        if(~any(ix)), error('MATLAB:plotmap', 'Key ID %d was not found in the shapefile key list', options.key(i)); end;
        CData(ix) = values(i);
    end;
end

% Set color axis limits to contain data range of finite values
r = isfinite(CData) & isreal(CData);
CLim = [min(CData(r)) max(CData(r))];
if(diff(CLim) == 0)
    CLim = CLim(1) * [0 1];
end;
if(isempty(CLim) || isnan(diff(CLim)) || isinf(diff(CLim)) || diff(CLim) == 0)
    CLim = [0 1];
end;
if ~isempty(options.clim)
    CLim=options.clim;
end

set(handles.Axes, 'CLim', CLim);

rgbData = mapcolor(CData, options.colormap, CLim);
rgbData(~r, :) = NaN; % mapping from CData to colors asigns color to invalid data. 

if(options.colorbar && ~options.density)
    colormap(handles.Axes, options.colormap);
    if(isempty(handles.Colorbar))
        handles.Colorbar = colorbar('peer', handles.Axes);
    end
end

%plot the polygons
%   polygons are not necessarily simple so it is necessary to stop
%   drawing a patch when a point is the same as an earlier one
for i=1:length(S.polygons)
    %i1 and i2 are the start and end indices for the next patch
    i1 = 1;
    handles.polygons{i} = [];
    counter = 0;
    while i1<length(S.polygons(i).X)
        counter = counter+1;
        i2 = find(S.polygons(i).X == S.polygons(i).X(i1) & S.polygons(i).Y == S.polygons(i).Y(i1) | isnan(S.polygons(i).Y));
        tmp_x = find(i2==i1)+1;
        if(tmp_x > length(i2)), tmp_x = length(i2); end; % if last point closes the polygon, there are no more points for other polygons composing the region
        i2 = i2(tmp_x);
        
        tmp_CDat = rgbData(i, :);
        if(any(isnan(tmp_CDat)) || options.density), tmp_CDat = NaN; end; % null color data must be a singlet NOT a triplet of NaN
        
        handles.polygons{i}(counter) = patch(S.polygons(i).X(i1:i2), S.polygons(i).Y(i1:i2), tmp_CDat, 'EdgeColor', options.border,...
                                             'Parent', handles.Axes, 'ButtonDownFcn', options.buttondownfcn, 'DisplayName', S.names{i},'linewidth',options.linewidth);
        i1 = i2+1;
    end
end

%density point plot (optional feature)
if options.density
    frecklesX = [];
    frecklesY = [];
    for i=1:length(S.polygons)
        if ~isnan(CData(i))
            xmin=min(S.polygons(i).X);
            xmax=max(S.polygons(i).X);
            ymin=min(S.polygons(i).Y);
            ymax=max(S.polygons(i).Y);
            for j=1:CData(i)
                x = random('unif',xmin,xmax);
                y = random('unif',ymin,ymax);
                while ~inmultpolygon(x,y,S.polygons(i).X,S.polygons(i).Y)
                    x = random('unif',xmin,xmax);
                    y = random('unif',ymin,ymax);
                end
                frecklesX(end+1)=x;
                frecklesY(end+1)=y;
            end
        end
    end
    handles.dots = scatter(handles.Axes, frecklesX, frecklesY, 'Parent', handles.Axes);
end

%plot the names (optional feature)
if options.labels
    handles.text = text(S.centers(:,1),S.centers(:,2),S.names(:),'Interpreter','none','HorizontalAlignment','center','Color',options.textcolor,'Parent',handles.Axes);
end

%just like inpolygon() except handles disconnected shapes (eg with islands)
function bool=inmultpolygon(x,y,X,Y)
bool = false;
i1 = 1;
while ~bool && i1<length(X)
    i2 = find(X==X(i1)&Y==Y(i1));
    i2 = i2(find(i2==i1)+1); %get the next index with coords matching i1
    bool = inpolygon(x,y,X(i1:i2),Y(i1:i2));
    i1 = i2+1;
end